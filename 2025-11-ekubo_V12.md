_Note: Not all issues are guaranteed to be correct._

## Low Severity Findings

### Self-Transfer Balance Invariant Violation

**Severity:** Low  

**Affected Contract(s):**
- `TokenWrapper`

**Affected Function(s):**
- `transfer()`

**Description:**

The transfer function allows users to transfer tokens to themselves without any guard. For non-CORE addresses, the function subtracts `amount` from the sender's balance and then re-adds it, resulting in zero net change while still emitting a `Transfer` event. This breaks the invariant that a recipient's recorded balance should always increase by `amount` when the recipient is neither CORE nor the zero address.

**Root Cause:**

Missing check for `to == msg.sender` leads to decrement and increment operations canceling out for self-transfers, yet the event is still emitted.

**Impact:**

Downstream accounting systems or event-driven processes may record a transfer that didn't actually change balances, leading to inconsistent state, erroneous analytics, or potential replay-based logic errors.

---


### Uncollected Fee Loss on Full Liquidity Removal

**Severity:** Low  

**Affected Contract(s):**
- `Core`

**Affected Function(s):**
- `updatePosition()`

**Description:**

When a user removes all liquidity for a position (liquidityNext == 0), the updatePosition function zeros out the position's feesPerLiquidityInsideLast (and liquidity) without first calculating or transferring any outstanding fees. This causes any fees accrued since the last checkpoint to be irretrievably wiped.

**Root Cause:**

In the full-removal code path of updatePosition, the contract unconditionally resets the fee checkpoint (feesPerLiquidityInsideLast) to (0,0) without invoking the fee computation or transfer logic, thus discarding uncollected fees.

**Impact:**

Liquidity providers who exit their positions forfeit any fees earned but not yet collected, leading to lost entitlements and direct financial loss for users.

---


### Unrestricted extraData Writing for Non-Existent Positions

**Severity:** Low  

**Affected Contract(s):**
- `Core`

**Affected Function(s):**
- `setExtraData()`

**Description:**

The setExtraData function allows any caller to store bytes16 extraData for a given (poolId, positionId) pair without verifying that the referenced position has been initialized or holds any non-zero liquidity. It computes the storage slot via CoreStorageLayout.poolPositionsSlot and writes directly to the mapping, even if the position has never been created or has zero liquidity.

**Root Cause:**

Missing existence check on the position before writing extraData. There is no require or liquidity>0 validation in setExtraData (or in poolPositionsSlot), so callers can target any slot in the poolPositions mapping.

**Impact:**

Attackers can inject arbitrary extraData into storage slots for positions that do not exist ("ghost" positions). This can corrupt off-chain indexing, confuse position enumeration logic, and potentially open doors for further exploits that assume the presence or absence of extraData implies a valid position.

---


### ERC721Receiver Check Bypass in mint Function

**Severity:** Low  

**Affected Contract(s):**
- `BaseNonfungibleToken`

**Affected Function(s):**
- `mint()`

**Description:**

The mint(bytes32) function uses ERC721._mint instead of _safeMint, bypassing the onERC721Received safety check. As a result, if a smart contract without the IERC721Receiver interface calls mint, the minted tokens are sent to the contract without verifying it can handle ERC721 tokens, potentially locking the tokens.

**Root Cause:**

Using ERC721._mint directly bypasses the onERC721Received hook enforced by _safeMint.

**Impact:**

Tokens minted to contracts that do not implement IERC721Receiver can become irretrievably locked, preventing any further transfer or usage of those tokens.

---


### Stuck Ether Due to Unused Payable Modifier

**Severity:** Low  

**Affected Contract(s):**
- `BasePositions`

**Affected Function(s):**
- `withdrawProtocolFees()`

**Description:**

The withdrawProtocolFees function is marked payable and thus can accept ETH, but neither it nor its internal call to BaseLocker.lock handles msg.value or forwards Ether. Furthermore, the contract lacks a receive/fallback or any direct ETH withdrawal mechanism. Consequently, any ETH sent to this function remains permanently trapped in the contract's balance.

**Root Cause:**

Adding the payable modifier to withdrawProtocolFees without reading or forwarding msg.value, combined with BaseLocker.lock hardcoding call value to zero and absence of any ETH withdrawal path.

**Impact:**

Attackers or misinformed users can send ETH to this function-either accidentally or deliberately-resulting in irrecoverable loss of funds locked in the contract.
